# Phase 3.3: HTTP/1.1 Serializer & Parser

**Date:** 2026-02-02
**Assembly:** TurboHTTP.Transport

## What Was Implemented

HTTP/1.1 request serialization and response parsing for the Transport layer. Three new files providing the wire-format layer that Phase 3.4 (RawSocketTransport) will integrate.

## Files Created

### `Runtime/Transport/Internal/EncodingHelper.cs`
- Shared static `Latin1` encoding field used by both serializer and parser
- Primary path: `Encoding.GetEncoding(28591)` (numeric codepage)
- IL2CPP fallback: custom `Latin1Encoding` class with all required overrides (`GetString`, `GetBytes(string)`, etc.)

### `Runtime/Transport/Http1/Http11RequestSerializer.cs`
- Static `SerializeAsync(UHttpRequest, Stream, CancellationToken)` method
- Request line + auto-added Host (with IPv6 bracket wrapping, non-default port)
- CRLF injection validation for all header names and values
- Multi-value header emission (one line per value)
- Transfer-Encoding / Content-Length mutual exclusion (RFC 9110 §8.6)
- Content-Length mismatch validation against body size
- Auto-added User-Agent and Connection: keep-alive
- Latin-1 encoding for header block

### `Runtime/Transport/Http1/Http11ResponseParser.cs`
- `ParsedResponse` internal class (StatusCode, Headers, Body, KeepAlive)
- Static `ParseAsync(Stream, HttpMethod, CancellationToken)` method
- Status line parsing (handles missing/multi-word reason phrases)
- 1xx interim response skipping (capped at 10)
- Header parsing with 100KB total size limit, 8KB per-line limit
- Transfer-Encoding precedence over Content-Length (RFC 9112 §6.1)
- Chunked body decoding with extension stripping and trailer consumption
- Content-Length body reading with multi-value consistency validation
- Read-to-end fallback with ArrayPool buffer
- HEAD/204/304 body skipping
- Keep-alive detection (HTTP/1.1 default, forced false on read-to-end)
- 100MB max response body size enforcement
- Bare LF line terminator acceptance (RFC 9112 §2.2 robustness)

## Decisions Made

1. **Bare LF acceptance:** Added per RFC 9112 §2.2 robustness recommendation. Many real-world servers/proxies send bare LF.
2. **ArrayPool in chunked reader:** Used pooled buffers for chunk data reads instead of per-chunk `new byte[]` to reduce GC pressure.
3. **MemoryStream disposal:** All MemoryStreams wrapped in `using` for code hygiene, even though `MemoryStream.Dispose()` is effectively a no-op.
4. **Host header defense-in-depth:** Auto-generated Host value passed through `ValidateHeader` even though `Uri.Host` is pre-validated by .NET.
5. **Connection header multi-token:** Documented as TODO for Phase 10. Current single-value check covers virtually all real-world servers.
6. **GC targets:** Phase 3 targets ~50KB GC per request. Serializer ~600-700 bytes, parser ~29KB from byte-by-byte ReadAsync. Both documented as Phase 10 rewrite targets.

7. **101 Switching Protocols:** Not treated as interim 1xx — breaks out of skip loop and returns to caller. Added to body-skip set since upgraded connections have no HTTP body.
8. **Chunk trailing CRLF:** Validated as empty; non-empty content throws FormatException to catch malformed responses.

## Review Results

- **Infrastructure review (pass 1):** Approved, no must-fix issues
- **Network review (pass 1):** 2 must-fix (bare LF handling, chunk CRLF maxLength), 5 should-fix
- **Both verification reviews (pass 2):** All issues resolved, no regressions
- **External review:** 3 additional issues (TE/CL mutual exclusion, 101 handling, chunk trailing validation)
- **Both verification reviews (pass 3):** All fixes confirmed correct, no regressions
